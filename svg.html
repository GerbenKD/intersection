<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>SVG test</title>
</head>

<body id = "body">

<script>
"use strict";

// globals
var XS = window.innerWidth, YS = window.innerHeight;
var UNUSED_ID = 0;

// create svg element
var body = document.getElementById("body");
var svg_namespace = "http://www.w3.org/2000/svg";
var svg = document.createElementNS(svg_namespace, "svg");
body.appendChild(svg);
svg.setAttribute("width", XS);
svg.setAttribute("height", YS);

var SMALL = 0.00001;

function test(x, y, v, name) {
    if (v && Math.abs(x)>10000 || Math.abs(y)>10000) {
	console.log(name+" at ("+x+","+y+") is valid but looks iffy");
    }
}

var g_lines         = document.createElementNS(svg_namespace, "g");
var g_highlighted   = document.createElementNS(svg_namespace, "g");
var g_points        = document.createElementNS(svg_namespace, "g");
var g_controlpoints = document.createElementNS(svg_namespace, "g");
svg.appendChild(g_lines);
svg.appendChild(g_highlighted);
svg.appendChild(g_points);
svg.appendChild(g_controlpoints);

// converts a mouse event to screen coords
function e2coord(e) {
    e = e || window.event;
    var docEl = document.documentElement;
    var scrollLeft = docEl.scrollLeft || document.body.scrollLeft;
    var scrollTop  = docEl.scrollTop || document.body.scrollTop;
    var x = e.pageX || (e.clientX  + scrollLeft);
    var y = e.pageY || (e.clientY  + scrollTop);
    return [x,y];
}


// ------------------------------- Constructions ---------------------------------------

function Construction() {
    this.gizmos = [];
}

Construction.prototype.add = function() {
    for (var i=0; i<arguments.length; i++) {
	this.gizmos.push(arguments[i]);
    }
}

Construction.prototype.unshift = function(gizmo) { 
    this.gizmos.unshift(gizmo); 
}

Construction.prototype.update = function() {
    for (var i=0; i<this.gizmos.length; i++) {
	var gizmo = this.gizmos[i];
	gizmo.recalculate_check_valid();
    }
}

Construction.prototype.find_all_duplicates = function() {
    console.log("Searching for duplicates");
    var ndup = 0;
    for (var i=0; i<this.gizmos.length; i++) {
	var gizmo = this.gizmos[i];
	if (gizmo.find_duplicates) { 
	    var dup = gizmo.find_duplicates();
	    if (dup.length > 0) {
		console.log("I found "+dup.length+" duplicates for the "+
			    gizmo.type+" at "+obj.toString());
		ndup++;
	    }
	}
    }
    console.log(ndup+" found.");
}

Construction.prototype.find_closest_point = function(point) {
    var closest_obj, closest_dist=-1;
    var i;
    for (i=0; i<this.gizmos.length; i++) {
	var gizmo = this.gizmos[i];
	if (!gizmo.distance) continue; // not a point
	var d = point.distance(gizmo);
	if (closest_dist==-1 || d<closest_dist) {
	    closest_dist = d;
	    closest_obj = gizmo;
	}
    }
    return [closest_obj, closest_dist];
}

// all objects with src as parent are redirected to dst
Construction.prototype.redirect = function(src, dst) {
    // found snap target, now find obj
    var i;
    for (i=0; i < this.gizmos.length; i++) {
	if (this.gizmos[i] === src) break;
    }
    if (i == this.gizmos.length) {
	console.error("Cannot find snappable in instance list");
	return;
    }
    // object found, now delete it and redirect all parent links to it
    src.trash();
    this.gizmos.splice(i, 1);
    for (; i < this.gizmos.length; i++) {
	var child = this.gizmos[i];
	if (child.parents) { 
	    for (var j=0; j<child.parents.length; j++) {
		if (child.parents[j]===src) child.parents[j] = dst;
	    }
	}
    }
}

// ----------------------------------- Gizmos ---------------------------------------

var Gizmo = new function() {

    this.valid = false;

    // Conveniently construct a subclass
    this.extend = function(constr) {
	constr.prototype = this;
	return new constr();
    };

    /* Instiantiates a class object, registers parents,
       assigns an ID and stores it in the objects list.
    */
    this.create = function() {
	var instance = this.extend(this.init);
	instance.parents = Array.prototype.slice.call(arguments);
	instance.recalculate_check_valid();
	return instance;
    }

    this.trash = function() {
	if (this.svg) { 
	    this.hide();
	    this.svg = null;
	}
    }

    this.recalculate = function() {}
    this.recalculate_graphics = function() {}
    this.recalculate_check_valid = function() {
	var v = true;
	if (this.parents) {
	    for (var i=0; i<this.parents.length; i++) {
		if (!this.parents[i].valid) { v = false; break; }
	    }
	}
	var old_valid = this.valid;
	this.valid = v;
	if (v) this.recalculate();
	// change visibility if validity changed
	if (this.svg) {
	    if (v) {
		this.recalculate_graphics();
		if (!old_valid) this.show();
	    } else {
		if (old_valid) this.hide();
	    }
	}

    }
   
    this.svg_create = function(group, name, attrib) {
	this.group = group;
	this.svg = document.createElementNS(svg_namespace, name);
	group.appendChild(this.svg);
	if (!attrib) attrib = {};
	if (!("pointer-events" in attrib)) {
	    attrib["pointer-events"] = "none";
	}
	this.svg_attrib(attrib);
    }

    this.svg_attrib = function(attrib) {
	for (var key in attrib) {
	    this.svg.setAttribute(key, attrib[key]);
	}
    }

    this.hide = function() { this.group.removeChild(this.svg); }
    this.show = function() { this.group.appendChild(this.svg); }

}

var Point = Gizmo.extend(function() {

    this.distance = function(other) {
	var dx = this.x - other.x, dy = this.y - other.y;
	return Math.sqrt(dx*dx+dy*dy);
    }

    this.toString = function() { return "("+this.x+","+this.y+")"; }

    this.recalculate_graphics = function() {
	this.svg.setAttribute("cx", this.x);
	this.svg.setAttribute("cy", this.y);
    }
});

var ControlPoint = Point.extend(function() {

    this.type = "ControlPoint";
    this.valid = true;

    this.at = function(x, y, mousedown) {
	var cp = this.extend(this.init);
	cp.parents = [];
	cp.set_position(x, y);
	cp.recalculate_graphics();
	cp.svg.onmousedown = function(e) { mousedown(cp, e); };
	return cp;
    }

    this.init = function() {
	this.svg_create(g_controlpoints, "circle", 
			{"r": 10, "fill": "blue", "stroke": "black", "stroke-width":2,
			"pointer-events": "all"});
    }
    
    this.set_position = function(x,y) { 
	this.x = x;
	this.y = y; 
    }

});


var LineOrCircle = Gizmo.extend(function() {
    
    this.add_intersections = function() {
	var len = Gizmo.INSTANCE_LIST.length;
	for (var i=0; i<len; i++) {
	    var other = Gizmo.INSTANCE_LIST[i];
	    if (other===this || !other.add_intersections) continue;
	    if (this.is_line) {
		if (other.is_line) {
		    LineLineIntersection.create(this, other);
		} else {
		    var cli = CircleLineIntersections.create(other, this);
		    SingleCircleIntersection.create(cli, 0);
		    SingleCircleIntersection.create(cli, 1);
		}
	    } else {
		var ci = other.is_line
		    ? CircleLineIntersections.create(this, other)
		    : CircleCircleIntersections.create(this, other);
		SingleCircleIntersection.create(ci, 0);
		SingleCircleIntersection.create(ci, 1);
	    }
	}
    }

});

var Line = LineOrCircle.extend(function() {

    this.type = "Line";

    this.init = function() {
	this.svg_create(g_lines, "line", 
			{"fill": "none", "stroke": "orange", "stroke-width": 1});
    }
   
    this.is_line = true;

    this.toString = function() {
	return this.parents[0].toString()+"-"+this.parents[1].toString(); 
    }

    this.compute_intersection_coords = function(x1,y1,x2,y2,x3,y3,x4,y4) {
	var x12 = x1-x2, x34=x3-x4, y12=y1-y2, y34=y3-y4;
	var N = x12*y34 - y12*x34;
	if (Math.abs(N)<SMALL) return null;
	var f1 = x1*y2-y1*x2, f2 = x3*y4-y3*x4;
	return [(f1*x34 - x12*f2)/N, (f1*y34 - y12*f2)/N];
    }

    this.compute_intersection = function(line1, line2) {
	return this.compute_intersection_coords(
	    line1.parents[0].x, line1.parents[0].y,
	    line1.parents[1].x, line1.parents[1].y,
	    line2.parents[0].x, line2.parents[0].y,
	    line2.parents[1].x, line2.parents[1].y);
    }

    this.recalculate_graphics = function() {
	// extend the line to the borders of the display using compute_line_intersection
	// (this could be optimized)
	var x1 = this.parents[0].x, y1 = this.parents[0].y,
	    x2 = this.parents[1].x, y2 = this.parents[1].y;
	var xy_l = this.compute_intersection_coords(x1,y1,x2,y2,0, 0, 0,YS);
	if (!xy_l || !isFinite(xy_l[1]) || xy_l[1]<0 || xy_l[1]>=YS) {
	    var xy_t = this.compute_intersection_coords(x1,y1,x2,y2,0,0,XS,0);
	    var xy_b = this.compute_intersection_coords(x1,y1,x2,y2,0,YS,XS,YS);
	    this.svg.setAttribute("x1", xy_t[0]);
	    this.svg.setAttribute("y1", 0);
	    this.svg.setAttribute("x2", xy_b[0]);
	    this.svg.setAttribute("y2", YS);
	} else {
	    var xy_r = this.compute_intersection_coords(x1,y1,x2,y2,XS,0,XS,YS);
	    this.svg.setAttribute("x1", 0);
	    this.svg.setAttribute("y1", xy_l[1]);
	    this.svg.setAttribute("x2", XS);
	    this.svg.setAttribute("y2", xy_r[1]);
	}
    }
});


var ConstructedPoint = Point.extend(function() {

    this.find_duplicates = function() {
	// find number of control points and back up their coordinates
	var cp = [];
	for (var i=0; i<Gizmo.INSTANCE_LIST.length; i++) {
	    var obj = Gizmo.INSTANCE_LIST[i];
	    if (!obj.at) break;
	    cp.push([obj.x, obj.y]);
	}

	// find all points that might match me. Note control points may also match!
	var candidates = [];
	for (var i=0; i<Gizmo.INSTANCE_LIST.length; i++) {
	    var obj = Gizmo.INSTANCE_LIST[i];
	    if (obj===this) continue; // obviously I match myself
	    if (this.valid != obj.valid) continue;
	    if (this.distance(obj) < SMALL) candidates.push(obj);
	}

	for (var test=0; test<5 && candidates.length>0; test++) {
	    // randomize control points
	    for (var i=0; i<cp.length; i++) {
		var cpo = Gizmo.INSTANCE_LIST[i];
		var dx = Math.random()*100-50, dy = Math.random()*100-50;
		cpo.set_position(cp[i][0]+dx, cp[i][1]+dy);
	    }
	    Gizmo.update();

	    // filter candidates
	    var new_candidates = [];
	    for (var i=0; i<candidates.length; i++) {
		var obj = candidates[i];
		if (this.valid==obj.valid && this.distance(obj)<SMALL) {
		    new_candidates.push(obj);
		}
	    }
	    candidates = new_candidates;
	}

	// repair control points
	for (var i=0; i<cp.length; i++) {
	    Gizmo.INSTANCE_LIST[i].set_position(cp[i][0], cp[i][1]);
	}
	Gizmo.update();
	return candidates;
    }


});


var LineLineIntersection = ConstructedPoint.extend(function() {

    this.type = "LineLineIntersection";

    this.init = function() { 
	this.svg_create(g_points, "circle", {"r": 5, "fill": "green"}); 
    }

    this.recalculate = function() {
	var line1 = this.parents[0], line2 = this.parents[1];
	var xy = Line.compute_intersection(line1, line2);
	if (xy && isFinite(xy[0]) && isFinite(xy[1])) {
	    this.x = xy[0];
	    this.y = xy[1];
	} else {
	    this.valid = false;
	}
	//test(this.x, this.y, this.valid, "lli");
    }

});


var Circle = LineOrCircle.extend(function() {
    
    this.type = "Circle";

    this.init = function() {
	this.svg_create(g_lines, "circle", 
			{"fill": "none", "stroke": "orange", "stroke-width": 1});
    }

    this.toString = function() { 
	return "("+parents[0].x+","+parents[0].y+","+this.radius(); 
    }

    this.centre = function() { return this.parents[0]; }
    this.radius2 = function() { 
	var c = this.parents[0], b = this.parents[1];
	var dx = c.x-b.x, dy = c.y-b.y;
	return dx*dx+dy*dy;
    }
    this.radius = function() { 
	var r2 = this.radius2();
	return Math.sqrt(this.radius2()); 
    }
   
    this.recalculate_graphics = function() {
	var cx = this.parents[0].x, cy = this.parents[0].y;
	var bx = this.parents[1].x, by = this.parents[1].y;
	var r = Math.sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));
	this.svg.setAttribute("cx", cx);
	this.svg.setAttribute("cy", cy);
	this.svg.setAttribute("r", r);
    }
});

var CircleLineIntersections = Gizmo.extend(function() {

    this.type = "CircleLineIntersections";

    this.init = function() {}

    this.recalculate = function() {
	var circle = this.parents[0], line = this.parents[1];
	var cx = circle.centre().x, cy = circle.centre().y, 
	    r2 = circle.radius2();
	var x1 = line.parents[0].x - cx, y1 = line.parents[0].y - cy;
	var x2 = line.parents[1].x - cx, y2 = line.parents[1].y - cy;
	var dx = x2-x1, dy = y2-y1;
	var dr2 = dx*dx+dy*dy;
	var D = x1*y2-x2*y1;
	var R = r2*dr2 - D*D;
	if (R<=SMALL || dr2<=SMALL) { this.valid = false; return; }
	var sqrtR = Math.sqrt(R)/dr2;
	D = D/dr2;
	this.x = [cx+D*dy+dx*sqrtR, cx+D*dy-dx*sqrtR];
	this.y = [cy-D*dx+dy*sqrtR, cy-D*dx-dy*sqrtR];
	if (!(isFinite(this.x[0]) && isFinite(this.y[0]) &&
	      isFinite(this.x[1]) && isFinite(this.y[1]))) this.valid = false;
	// test(this.x[0], this.y[0], this.valid, "cli0");
	// test(this.x[1], this.y[1], this.valid, "cli1");
    }
});

var CircleCircleIntersections = Gizmo.extend(function() {

    this.type = "CircleCircleIntersections";

    this.init = function() {}

    this.recalculate = function() {
	var centre1 = this.parents[0].centre(), centre2 = this.parents[1].centre();
	var x1 = centre1.x, y1 = centre1.y;
	var x2 = centre2.x, y2 = centre2.y;
	var r1 = this.parents[0].radius(), r2 = this.parents[1].radius();
	var dx = x2-x1, dy = y2-y1;
	var d2 = dx*dx+dy*dy;
	var D = ((r1+r2)*(r1+r2)/d2-1) * (1-(r1-r2)*(r1-r2)/d2);
	if (D<=0) { this.valid = false; return; }
	var K = 0.25*Math.sqrt(D);
	var dr2 = 0.5*(r1*r1-r2*r2)/d2;
	var xs = 0.5*(x1+x2)+dx*dr2, xt =  2*dy*K;
	var ys = 0.5*(y1+y2)+dy*dr2, yt = -2*dx*K;
	this.x = [xs+xt, xs-xt];
	this.y = [ys+yt, ys-yt];
	if (!(isFinite(xs) && isFinite(xt) && isFinite(ys) && isFinite(yt))) 
	    this.valid = false;
	// test(this.x[0], this.y[0], this.valid, "cci0");
	// test(this.x[1], this.y[1], this.valid, "cci1");
    }
});


var SingleCircleIntersection = ConstructedPoint.extend(function() {

    this.type = "SingleCircleIntersection";

    this.init = function() { 
	this.svg_create(g_points, "circle", {"r": 5, "fill": "green"}); 
    }

    this.create = function(point_collection, which) {
	var instance = Gizmo.create.call(this, point_collection);
	instance.which = which;
	return instance;
    }

    this.recalculate = function() {
	this.valid = this.parents[0].valid;
	if (this.valid) {
	    this.x = this.parents[0].x[this.which];
	    this.y = this.parents[0].y[this.which];
	}
    }

});


// ------------------------------------ Main program -----------------------------------

function sandbox() {

    var C = new Construction();
    var Tools = [];
    var MOUSE, DRAGGING;


    function mousedown(tool_ix) {
	return function(point, event) {
	    var xy = e2coord(event);
	    DRAGGING = [point, point.x - xy[0], point.y - xy[1], tool_ix];
	}
    }
	

    window.onkeypress = function(e) {
	var mx = MOUSE[0], my = MOUSE[1];
	var nt = Tools.length;
	switch (e.keyCode) {
	case 48: 
	    var p = ControlPoint.at(mx, my, mousedown(-1)); 
	    C.unshift(p); 
	    break;
	case 49:
	    var p1 = ControlPoint.at(Math.max(50,mx-0.1*XS),     my, mousedown(nt));
	    var p2 = ControlPoint.at(Math.min(XS-50, mx+0.1*XS), my, mousedown(nt));
	    var l  = Line.create(p1, p2);
	    p1.svg_attrib({"fill": "cyan"});
	    p2.svg_attrib({"fill": "cyan"});
	    var c_tmp = new Construction();
	    c_tmp.add(p1, p2, l);
	    Tools.push(c_tmp);
	    break;
	case 50:
	    var p1 = ControlPoint.at(mx, my, mousedown(nt));
	    var p2 = ControlPoint.at(mx, my>YS/2 ? my - 0.1*YS : my + 0.1*YS, mousedown(nt));
	    var c = Circle.create(p1, p2);
	    p1.svg_attrib({"fill": "cyan"});
	    p2.svg_attrib({"fill": "cyan"});
	    var c_tmp = new Construction();
	    c_tmp.add(p1, p2, c);
	    Tools.push(c_tmp);
	    break;
	case 52: 
	    C.find_all_duplicates();
	    break;
	}
    }

    window.onmousemove = function(e) {
	MOUSE = e2coord(e);
	if (!DRAGGING) return;
	var obj = DRAGGING[0], x0 = DRAGGING[1], y0 = DRAGGING[2];
	obj.set_position(x0+MOUSE[0], y0+MOUSE[1]);
	if (DRAGGING[3]==-1) {
	    // update everything
	    C.update();
	    for (var i=0; i<Tools.length; i++)  {
		Tools[i].update();
	    }
	} else {
	    Tools[DRAGGING[3]].update();
	}
    }

    /* Bugs and things to think about:
       - currently, can only snap to points that are not built on top of a snappable.
         however, the difference with normal points is not visible in the UI
       - two points of a line/circle can be snapped to the same point
    */
    window.onmouseup = function(e) {
	if (DRAGGING) {
	    var obj = DRAGGING[0], tool_ix = DRAGGING[3];
	    DRAGGING = null;
	    if (tool_ix!=-1) {
		var closest = C.find_closest_point(obj);
		if (closest[1]!=-1 && closest[1]<=10) {
		    Tools[tool_ix].redirect(obj, closest[0]);
		    Tools[tool_ix].update(); // redraw after snapping
		}
	    }
	}
    }
}

sandbox();

// demo2();


</script>

</body>
</html>
